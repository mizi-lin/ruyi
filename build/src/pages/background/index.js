import{c as ce}from"../../../assets/js/jsx-runtime.YiCzgiTN.js";import{g as le,b as de,a as Ae,i as we,l as ue,c as be,U as b,D as i,d as D,t as Y,G as R,e as $,f as H,W as A,T as C,R as _,S as N,h as Z,j as ee,u as pe,k as xe,m as se,n as he,o as fe,p as ae,q as z,r as te}from"../../../assets/js/index.Ccof6RHb.js";import{d as ye,M}from"../../../assets/js/constants.Dc8TDCOl.js";var Te={exports:{}};(function(e,s){(function(a,t){t(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:ce,function(a){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)a.exports=globalThis.browser;else{const t="The message port closed before a response was received.",m=r=>{const g={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(g).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class l extends WeakMap{constructor(o,d=void 0){super(d),this.createItem=o}get(o){return this.has(o)||this.set(o,this.createItem(o)),super.get(o)}}const u=n=>n&&typeof n=="object"&&typeof n.then=="function",f=(n,o)=>(...d)=>{r.runtime.lastError?n.reject(new Error(r.runtime.lastError.message)):o.singleCallbackArg||d.length<=1&&o.singleCallbackArg!==!1?n.resolve(d[0]):n.resolve(d)},h=n=>n==1?"argument":"arguments",P=(n,o)=>function(w,...x){if(x.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${h(o.minArgs)} for ${n}(), got ${x.length}`);if(x.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${h(o.maxArgs)} for ${n}(), got ${x.length}`);return new Promise((y,T)=>{if(o.fallbackToNoCallback)try{w[n](...x,f({resolve:y,reject:T},o))}catch(c){console.warn(`${n} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,c),w[n](...x),o.fallbackToNoCallback=!1,o.noCallback=!0,y()}else o.noCallback?(w[n](...x),y()):w[n](...x,f({resolve:y,reject:T},o))})},U=(n,o,d)=>new Proxy(o,{apply(w,x,y){return d.call(x,n,...y)}});let S=Function.call.bind(Object.prototype.hasOwnProperty);const L=(n,o={},d={})=>{let w=Object.create(null),x={has(T,c){return c in n||c in w},get(T,c,W){if(c in w)return w[c];if(!(c in n))return;let p=n[c];if(typeof p=="function")if(typeof o[c]=="function")p=U(n,n[c],o[c]);else if(S(d,c)){let k=P(c,d[c]);p=U(n,n[c],k)}else p=p.bind(n);else if(typeof p=="object"&&p!==null&&(S(o,c)||S(d,c)))p=L(p,o[c],d[c]);else if(S(d,"*"))p=L(p,o[c],d["*"]);else return Object.defineProperty(w,c,{configurable:!0,enumerable:!0,get(){return n[c]},set(k){n[c]=k}}),p;return w[c]=p,p},set(T,c,W,p){return c in w?w[c]=W:n[c]=W,!0},defineProperty(T,c,W){return Reflect.defineProperty(w,c,W)},deleteProperty(T,c){return Reflect.deleteProperty(w,c)}},y=Object.create(n);return new Proxy(y,x)},I=n=>({addListener(o,d,...w){o.addListener(n.get(d),...w)},hasListener(o,d){return o.hasListener(n.get(d))},removeListener(o,d){o.removeListener(n.get(d))}}),oe=new l(n=>typeof n!="function"?n:function(d){const w=L(d,{},{getContent:{minArgs:0,maxArgs:0}});n(w)}),G=new l(n=>typeof n!="function"?n:function(d,w,x){let y=!1,T,c=new Promise(E=>{T=function(v){y=!0,E(v)}}),W;try{W=n(d,w,T)}catch(E){W=Promise.reject(E)}const p=W!==!0&&u(W);if(W!==!0&&!p&&!y)return!1;const k=E=>{E.then(v=>{x(v)},v=>{let j;v&&(v instanceof Error||typeof v.message=="string")?j=v.message:j="An unexpected error occurred",x({__mozWebExtensionPolyfillReject__:!0,message:j})}).catch(v=>{console.error("Failed to send onMessage rejected reply",v)})};return k(p?W:c),!0}),ge=({reject:n,resolve:o},d)=>{r.runtime.lastError?r.runtime.lastError.message===t?o():n(new Error(r.runtime.lastError.message)):d&&d.__mozWebExtensionPolyfillReject__?n(new Error(d.message)):o(d)},K=(n,o,d,...w)=>{if(w.length<o.minArgs)throw new Error(`Expected at least ${o.minArgs} ${h(o.minArgs)} for ${n}(), got ${w.length}`);if(w.length>o.maxArgs)throw new Error(`Expected at most ${o.maxArgs} ${h(o.maxArgs)} for ${n}(), got ${w.length}`);return new Promise((x,y)=>{const T=ge.bind(null,{resolve:x,reject:y});w.push(T),d.sendMessage(...w)})},me={devtools:{network:{onRequestFinished:I(oe)}},runtime:{onMessage:I(G),onMessageExternal:I(G),sendMessage:K.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:K.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},F={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return g.privacy={network:{"*":F},services:{"*":F},websites:{"*":F}},L(r,me,g)};a.exports=m(chrome)}})})(Te);var J=function(){try{var e=le(Object,"defineProperty");return e({},"",{}),e}catch{}}();function We(e,s,a){s=="__proto__"&&J?J(e,s,{configurable:!0,enumerable:!0,value:a,writable:!0}):e[s]=a}function ve(e,s,a,t){for(var m=-1,r=e==null?0:e.length;++m<r;){var g=e[m];s(t,g,a(g),e)}return t}function De(e,s,a,t){return de(e,function(m,r,g){s(t,m,a(m),g)}),t}function Me(e,s){return function(a,t){var m=we(a)?ve:De,r=s?s():{};return m(a,e,Ae(t),r)}}var Be=Object.prototype,Re=Be.hasOwnProperty,Se=Me(function(e,s,a){Re.call(e,a)?e[a].push(s):We(e,a,[s])});function re(e,s){const a=Se(e,s);return ue.mapKeys(a,(t,m)=>be(m))}async function Ce(e){const{id:s,url:a,favIconUrl:t,title:m,lastAccessed:r}=e;await b(D,i.UrlDB.URLsMap,a,g=>({...g,url:a,favIconUrl:t,title:m,lastAccessed:r})),await b(D,i.UrlDB.URLTabsMap,s,(g=new Set)=>(g.delete(s),g.add(s),g))}async function Ue(){const e=await chrome.history.search({text:"",maxResults:2e4,startTime:ye("2000-01-01").valueOf()}),s=Y(e,"url");await D.setItem(i.UrlDB.HistoriesMap,s);const a=await R(D,i.UrlDB.URLsMap),t=await $(D,i.UrlDB.NoSignURLsSet);await R(D,i.UrlDB.URLOriginFaviconMap);for await(const m of e){const{url:r}=m;if(!a.has(r)){const{host:g,hostname:l=g}=new URL(r);t.add(r),a.set(r,{url:r,title:l})}}await D.setItem(i.UrlDB.URLsMap,a),await D.setItem(i.UrlDB.NoSignURLsSet,t)}async function ke(e){e=e??await chrome.tabs.query({});for await(const s of e){const{pendingUrl:a,url:t=a,favIconUrl:m}=s;if(t&&m){const{host:r,hostname:g=r}=new URL(t);await b(D,i.UrlDB.URLOriginFaviconMap,g,m)}}}const Le=async()=>{const e=await H(),s=re(e,"windowId"),a=Object.entries(s).map(([g,l])=>[+g,new Set(l.map(({id:u})=>u))]),t=await R(A,i.WindowDB.AllWindowTabsMap),m=new Set;for await(const[g,l]of a)m.add(g),t.set(g,l);await A.setItem(i.WindowDB.ActiveWindowsSet,m),await A.setItem(i.WindowDB.AllWindowTabsMap,t),await ne();const r=await R(A,i.WindowDB.WindowURLsHistoryMap);for await(const g of e){const l=r.get(g.windowId)??new Set;l.add(g.url),r.set(g.windowId,l)}await A.setItem(i.WindowDB.WindowURLsHistoryMap,r)};async function ne(){const e=await chrome.windows.getCurrent();await A.setItem(i.WindowDB.CurrentId,e.id)}async function ie(){const e=await $(A,i.WindowDB.ActiveWindowsSet),s=await R(A,i.WindowDB.AllWindowTabsMap),a=await R(C,i.TabDB.TabsMap),t=Array.from(s),m=new Map,r=[];for(const[g,l]of t){const u=[...l].map(f=>{var h;return(h=a.get(f))==null?void 0:h.url}).sort().join(",");m.has(u)?(r.push(e.has(g)?m.get(u):g),m.set(u,e.has(g)?g:m.get(u))):m.set(u,g)}if(r!=null&&r.length)for await(const g of r)await _(A,i.WindowDB.AllWindowTabsMap,g)}async function O(e,s){const a=await Z.getItem(e);ee(a)&&await Z.setItem(e,s)}async function Ee(){await O(N.TabsShowHistoryWindows,!0),await O(N.TabsShowActiveWindows,!0),await O(N.TabsShowTopViewer,!0),await O(N.TabsOnlyMatched,!1)}chrome.runtime.onInstalled.addListener(async(...e)=>{console.log("onInstalled --->>> ",e);const s=await H();await pe(s),await ke(s),await Ue(),await Le(),await ie(),await Ee()});chrome.runtime.onRestartRequired.addListener(async()=>{await ie()});chrome.commands.onCommand.addListener(e=>{console.log(`Command --> "${e}" triggered`)});const V=()=>chrome.runtime.getURL("src/pages/app/index.html"),Pe=async()=>{const[e]=await chrome.tabs.query({url:V()});return e==null?void 0:e.id},B=async(e,s={})=>{const a=await Pe();a&&chrome.tabs.sendMessage(a,{type:e,...s})};chrome.windows.onCreated.addListener(async e=>{await xe(A,i.WindowDB.ActiveWindowsSet,e.id),await B(M.DataReload),console.log("window onCreate --->>",e)});chrome.windows.onRemoved.addListener(async e=>{await se(A,i.WindowDB.ActiveWindowsSet,e),await he(e);const s=await chrome.windows.getLastFocused();s&&await A.setItem(i.WindowDB.CurrentId,s.id),await B(M.DataReload),console.log("window onRemoved --->>",e)});chrome.windows.onFocusChanged.addListener(async e=>{e>0&&await A.setItem(i.WindowDB.CurrentId,e),await B(M.DataReload)},{windowTypes:["normal"]});chrome.tabs.onCreated.addListener(async e=>{console.log("tabs onCreated --->>",e)});chrome.tabs.onActivated.addListener(async e=>{const{tabId:s}=e,a=await chrome.tabs.get(s);fe(a)||(await b(C,i.TabDB.TabsMap,s,t=>({...t,...a})),await B(M.DataReload),console.log("tabs onActived --->>",e))});chrome.tabs.onMoved.addListener(async(e,s)=>{console.log("....",e,s);const a=await R(C,i.TabDB.TabsMap),{windowId:t}=s,{windowId:m}=a.get(e),r=await chrome.tabs.get(e);await b(C,i.TabDB.TabsMap,e,u=>({...u,...r}));const g=await chrome.tabs.query({windowId:m}),l=await chrome.tabs.query({windowId:t});await b(A,i.WindowDB.AllWindowTabsMap,m,()=>new Set(g.map(u=>u.id))),await b(A,i.WindowDB.AllWindowTabsMap,t,()=>new Set(l.map(u=>u.id))),await b(A,i.WindowDB.WindowURLsHistoryMap,t,(u=new Set)=>(u.add(r.url),u)),await ne(),await B(M.DataReload),console.log("tabs onMoved --->>",e,s)});chrome.tabs.onDetached.addListener(async(e,s)=>{const{oldWindowId:a,oldPosition:t}=s,m=await chrome.tabs.query({windowId:a});await b(A,i.WindowDB.AllWindowTabsMap,a,ae(m,"id")),console.log("tabs onDetached --->>",e,s)});chrome.tabs.onAttached.addListener(async(e,s)=>{const{newWindowId:a,newPosition:t}=s,m=await chrome.tabs.query({windowId:a});await b(A,i.WindowDB.AllWindowTabsMap,a,ae(m,"id"));const r=await chrome.tabs.get(e);await b(C,i.TabDB.TabsMap,e,r),await B(M.DataReload),console.log("tabs onAttached --->>",e,s)});chrome.tabs.onRemoved.addListener(async(e,s)=>{const{windowId:a,isWindowClosing:t}=s;if(!t){const m=await H({windowId:a});await b(A,i.WindowDB.AllWindowTabsMap,a,()=>new Set(m.map(r=>r.id)))}await B(M.DataReload),console.log("tabs onRemoved --->>",e,s)});chrome.tabs.onUpdated.addListener(async(e,s,a)=>{if((s==null?void 0:s.status)==="complete"){const{pinned:t,index:m}=a;await Ce(a),await z(e,a),await b(A,i.WindowDB.AllWindowTabsMap,a.windowId,(r=new Set)=>(t?r=te(r,m,e):r.add(e),r)),await B(M.DataReload)}ee(a.pinned)||(await z(e,a),await B(M.DataReload)),console.log("tabs onUpdated --->>",s==null?void 0:s.status,e,s,a)});const{create:Ie,move:Ne,update:Oe}=chrome.tabs;chrome.action.onClicked.addListener(async e=>{const{windowId:s}=e,a=V();let[t]=await chrome.tabs.query({url:a});t||(t=await Ie({url:a,windowId:s,index:0,active:!0,pinned:!0})),t&&(t.windowId!==s&&await Ne(t.id,{windowId:s,index:0}),await Oe(t.id,{highlighted:!0,active:!0,pinned:!0})),await A.setItem(i.WindowDB.CurrentId,s)});chrome.history.onVisited.addListener(async e=>{await b(D,i.UrlDB.HistoriesMap,e.url,e),await B(M.DataReload),console.log("tabs onVisited --->>",e)});async function Q(e){return(await $(A,i.WindowDB.ActiveWindowsSet)).has(e)}async function X({tabs:e}){const s=re(e,"windowId"),a=await $(A,i.WindowDB.ActiveWindowsSet);for await(const[t,m]of Object.entries(s)){const r=+t,g=a.has(r),l=m.map(h=>h.id),u=await R(A,i.WindowDB.AllWindowTabsMap);if(!u)return;const f=u.get(+r);for await(const h of l)g&&await chrome.tabs.remove(h),f.delete(h);f.size?await b(A,i.WindowDB.AllWindowTabsMap,r,f):(await _(A,i.WindowDB.AllWindowTabsMap,r),await se(A,i.WindowDB.ActiveWindowsSet,r))}}async function _e({windowId:e,tab:s,active:a}){if(a)return await chrome.tabs.remove(s.id);await b(A,i.WindowDB.AllWindowTabsMap,e,(t=new Set)=>(t.delete(s.id),t))}async function $e({tab:e,active:s}){return console.log("pinnedTab",e,s),s?await chrome.tabs.update(e.id,{pinned:!e.pinned}):await chrome.tabs.create({url:e.url,pinned:!e.pinned,windowId:chrome.windows.WINDOW_ID_CURRENT})}async function Fe(){const e=V(),[s]=await chrome.tabs.query({url:e});if(!s)return await chrome.tabs.create({url:e,windowId:chrome.windows.WINDOW_ID_CURRENT,index:0,active:!0,pinned:!0});const a=await chrome.windows.getCurrent();a.id!==s.windowId&&await chrome.tabs.move(s.id,{windowId:a.id,index:0}),await chrome.tabs.update(s.id,{active:!0,highlighted:!0,pinned:!0})}const q={openTab:async({windowId:e,tab:s,active:a,incognito:t=!1})=>{if(!e)return await chrome.windows.create({url:s.url,incognito:t});if(a&&e===s.windowId)return await chrome.windows.update(e,{focused:!0}),await chrome.tabs.update(s.id,{active:!0,highlighted:!0});await chrome.tabs.create({url:s.url,windowId:chrome.windows.WINDOW_ID_CURRENT,active:!0})},moveTab:async({sourceWindowId:e,targetWindowId:s,tabId:a,index:t},m)=>{const r=await Q(s),g=await Q(e);if(!g&&await b(A,i.WindowDB.AllWindowTabsMap,e,l=>(l.delete(a),l)),!r){if(g)try{await chrome.tabs.remove(a)}catch{}await b(A,i.WindowDB.AllWindowTabsMap,s,l=>te(l,t,a));return}try{await chrome.tabs.get(a),await chrome.tabs.move(a,{windowId:s,index:t})}catch{const u=await R(C,i.TabDB.TabsMap),{url:f}=u.get(a)??{};f&&await chrome.tabs.create({url:f,windowId:s,index:t})}},pinnedTab:$e,removeTab:_e,removeVariousTabs:X,openWindow:async({windowId:e,active:s,tabs:a=[],type:t="deleteSource"})=>{if(s&&e)return await chrome.windows.update(e,{focused:!0});const m=a.map(l=>l==null?void 0:l.url).filter(Boolean);await chrome.windows.create({url:m,incognito:!1}),e&&await _(A,i.WindowDB.AllWindowTabsMap,e);const{tabs:r}=await chrome.windows.getCurrent({populate:!0}),g=Y(a,"url");for await(const l of r)await b(C,i.TabDB.TabsMap,l.id,async()=>{const{url:u,pendingUrl:f}=l,h=u||f,P=g.get(h);if(P){const{title:U,favIconUrl:S,id:L}=P;return{...l,title:U,favIconUrl:S}}else{const U=new URL(h);return{...l,title:U.hostname,url:h}}});t==="deleteSource"&&await X({tabs:a})},removeWindow:async({windowId:e,active:s})=>{if(s)return await chrome.windows.remove(e);await _(A,i.WindowDB.AllWindowTabsMap,e)},openApp:Fe};chrome.runtime.onMessage.addListener(async(e,s,a)=>{var r;const{type:t,options:m}=e;console.log("from-app-message",e);try{await((r=q[t])==null?void 0:r.call(q,m,a,s))}catch(g){console.trace(g)}});console.log("background loaded");
