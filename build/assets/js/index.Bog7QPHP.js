import{R as Z}from"./jsx-runtime.YiCzgiTN.js";import{R as wr}from"./index.CrDBv-OJ.js";var Yn={};function Nr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Lr=Nr,U=Lr;function Vr(e){return!!e&&typeof e.then=="function"}var G=Vr;function Cr(e,t){if(e!=null)return e;throw U(t??"Got unexpected null or undefined")}var q=Cr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class gt{getValue(){throw U("BaseLoadable")}toPromise(){throw U("BaseLoadable")}valueMaybe(){throw U("BaseLoadable")}valueOrThrow(){throw U(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw U("BaseLoadable")}promiseOrThrow(){throw U(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw U("BaseLoadable")}errorOrThrow(){throw U(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw U("BaseLoadable")}}class $r extends gt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return G(n)?Ve(n):Oe(n)?n:ot(n)}catch(n){return G(n)?Ve(n.next(()=>this.map(t))):bt(n)}}}class Mr extends gt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Xn extends gt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ve(this.contents.then(n=>{const o=t(n);if(Oe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(G(n))return n.then(()=>this.map(t).contents);throw n}))}}function ot(e){return Object.freeze(new $r(e))}function bt(e){return Object.freeze(new Mr(e))}function Ve(e){return Object.freeze(new Xn(e))}function Jn(){return Object.freeze(new Xn(new Promise(()=>{})))}function Ur(e){return e.every(t=>t.state==="hasValue")?ot(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?bt(q(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ve(Promise.all(e.map(t=>t.contents)))}function Qn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Oe(r)?r:G(r)?Ve(r):ot(r)),o=Ur(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Oe(e){return e instanceof gt}const Ir={of:e=>G(e)?Ve(e):Oe(e)?e:ot(e),error:e=>bt(e),loading:()=>Jn(),all:Qn,isLoadable:Oe};var $e={loadableWithValue:ot,loadableWithError:bt,loadableWithPromise:Ve,loadableLoading:Jn,loadableAll:Qn,isLoadable:Oe,RecoilLoadable:Ir},Dr=$e.loadableWithValue,kr=$e.loadableWithError,Br=$e.loadableWithPromise,Pr=$e.loadableLoading,Or=$e.loadableAll,xr=$e.isLoadable,Fr=$e.RecoilLoadable,rt=Object.freeze({__proto__:null,loadableWithValue:Dr,loadableWithError:kr,loadableWithPromise:Br,loadableLoading:Pr,loadableAll:Or,isLoadable:xr,RecoilLoadable:Fr});const Jt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function zr(e,t){var n,o;const r=(n=Yn[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw U(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function Wr(e,t){var n;const o=(n=Yn[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Gr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(zr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Jt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),Wr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Jt.RECOIL_GKS_ENABLED.add(n)})}))}Gr();var Ge=Jt;function Tt(e){return Ge.RECOIL_GKS_ENABLED.has(e)}Tt.setPass=e=>{Ge.RECOIL_GKS_ENABLED.add(e)};Tt.setFail=e=>{Ge.RECOIL_GKS_ENABLED.delete(e)};Tt.clear=()=>{Ge.RECOIL_GKS_ENABLED.clear()};var W=Tt;function Kr(e,t,{error:n}={}){return null}var Hr=Kr,cn=Hr,Gt,Kt,Ht;const jr=(Gt=Z.createMutableSource)!==null&&Gt!==void 0?Gt:Z.unstable_createMutableSource,eo=(Kt=Z.useMutableSource)!==null&&Kt!==void 0?Kt:Z.unstable_useMutableSource,to=(Ht=Z.useSyncExternalStore)!==null&&Ht!==void 0?Ht:Z.unstable_useSyncExternalStore;function qr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function Zr(){return W("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:W("recoil_sync_external_store")&&to!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:W("recoil_mutable_source")&&eo!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?W("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:W("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function Yr(){return!1}var at={createMutableSource:jr,useMutableSource:eo,useSyncExternalStore:to,currentRendererSupportsUseSyncExternalStore:qr,reactMode:Zr,isFastRefreshEnabled:Yr};class ln{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class no extends ln{}class oo extends ln{}function Xr(e){return e instanceof no||e instanceof oo}var At={AbstractRecoilValue:ln,RecoilState:no,RecoilValueReadOnly:oo,isRecoilValue:Xr},Jr=At.AbstractRecoilValue,Qr=At.RecoilState,ea=At.RecoilValueReadOnly,ta=At.isRecoilValue,xe=Object.freeze({__proto__:null,AbstractRecoilValue:Jr,RecoilState:Qr,RecoilValueReadOnly:ea,isRecoilValue:ta});function na(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var Et=na;class ro{}const oa=new ro,Ce=new Map,un=new Map;function ra(e){return Et(e,t=>q(un.get(t)))}function aa(e){if(Ce.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function sa(e){Ge.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&aa(e.key),Ce.set(e.key,e);const t=e.set==null?new xe.RecoilValueReadOnly(e.key):new xe.RecoilState(e.key);return un.set(e.key,t),t}class ao extends Error{}function ia(e){const t=Ce.get(e);if(t==null)throw new ao(`Missing definition for RecoilValue: "${e}""`);return t}function ca(e){return Ce.get(e)}const St=new Map;function la(e){var t;if(!W("recoil_memory_managament_2020"))return;const n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=so(e))===null||o===void 0||o(),St.delete(e)}}function ua(e,t){W("recoil_memory_managament_2020")&&(t===void 0?St.delete(e):St.set(e,t))}function so(e){return St.get(e)}var ce={nodes:Ce,recoilValues:un,registerNode:sa,getNode:ia,getNodeMaybe:ca,deleteNodeConfigIfPossible:la,setConfigDeletionHandler:ua,getConfigDeletionHandler:so,recoilValuesForKeys:ra,NodeMissingError:ao,DefaultValue:ro,DEFAULT_VALUE:oa};function da(e,t){t()}var fa={enqueueExecution:da};function ha(e,t){return t={exports:{}},e(t,t.exports),t.exports}var va=ha(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},v=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,R=0,m=c.length;R<m;++R){var g=c.charCodeAt(R);h=(h<<5)-h+g|0}return h},p=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},C=function(i,h){return h>>>i&a},V=function(i){return 1<<i},y=function(i,h){return p(i&h-1)},E=function(i,h,R,m){var g=m;if(!i){var L=m.length;g=new Array(L);for(var w=0;w<L;++w)g[w]=m[w]}return g[h]=R,g},Y=function(i,h,R){var m=R.length-1,g=0,L=0,w=R;if(i)g=L=h;else for(w=new Array(m);g<h;)w[L++]=R[g++];for(++g;g<=m;)w[L++]=R[g++];return i&&(w.length=m),w},oe=function(i,h,R,m){var g=m.length;if(i){for(var L=g;L>=h;)m[L--]=m[L];return m[h]=R,m}for(var w=0,N=0,D=new Array(g+1);w<h;)D[N++]=m[w++];for(D[h]=R;w<g;)D[++N]=m[w++];return D},A=1,P=2,Q=3,z=4,K={__hamt_isEmpty:!0},X=function(i){return i===K||i&&i.__hamt_isEmpty},ae=function(i,h,R,m){return{type:A,edit:i,hash:h,key:R,value:m,_modify:Ie}},ye=function(i,h,R){return{type:P,edit:i,hash:h,children:R,_modify:De}},te=function(i,h,R){return{type:Q,edit:i,mask:h,children:R,_modify:O}},de=function(i,h,R){return{type:z,edit:i,size:h,children:R,_modify:x}},Ue=function(i){return i===K||i.type===A||i.type===P},ee=function(i,h,R,m,g){for(var L=[],w=m,N=0,D=0;w;++D)w&1&&(L[D]=g[N++]),w>>>=1;return L[h]=R,de(i,N+1,L)},le=function(i,h,R,m){for(var g=new Array(h-1),L=0,w=0,N=0,D=m.length;N<D;++N)if(N!==R){var j=m[N];j&&!X(j)&&(g[L++]=j,w|=1<<N)}return te(i,w,g)},we=function c(i,h,R,m,g,L){if(R===g)return ye(i,R,[L,m]);var w=C(h,R),N=C(h,g);return te(i,V(w)|V(N),w===N?[c(i,h+o,R,m,g,L)]:w<N?[m,L]:[L,m])},fe=function(i,h,R,m,g,L,w,N){for(var D=g.length,j=0;j<D;++j){var se=g[j];if(R(w,se.key)){var re=se.value,ve=L(re);return ve===re?g:ve===u?(--N.value,Y(i,j,g)):E(i,j,ae(h,m,w,ve),g)}}var pe=L();return pe===u?g:(++N.value,E(i,D,ae(h,m,w,pe),g))},ge=function(i,h){return i===h.edit},Ie=function(i,h,R,m,g,L,w){if(h(L,this.key)){var N=m(this.value);return N===this.value?this:N===u?(--w.value,K):ge(i,this)?(this.value=N,this):ae(i,g,L,N)}var D=m();return D===u?this:(++w.value,we(i,R,this.hash,this,g,ae(i,g,L,D)))},De=function(i,h,R,m,g,L,w){if(g===this.hash){var N=ge(i,this),D=fe(N,i,h,this.hash,this.children,m,L,w);return D===this.children?this:D.length>1?ye(i,this.hash,D):D[0]}var j=m();return j===u?this:(++w.value,we(i,R,this.hash,this,g,ae(i,g,L,j)))},O=function(i,h,R,m,g,L,w){var N=this.mask,D=this.children,j=C(R,g),se=V(j),re=y(N,se),ve=N&se,pe=ve?D[re]:K,ke=pe._modify(i,h,R+o,m,g,L,w);if(pe===ke)return this;var ut=ge(i,this),He=N,je=void 0;if(ve&&X(ke)){if(He&=~se,!He)return K;if(D.length<=2&&Ue(D[re^1]))return D[re^1];je=Y(ut,re,D)}else if(!ve&&!X(ke)){if(D.length>=s)return ee(i,j,ke,N,D);He|=se,je=oe(ut,re,ke,D)}else je=E(ut,re,ke,D);return ut?(this.mask=He,this.children=je,this):te(i,He,je)},x=function(i,h,R,m,g,L,w){var N=this.size,D=this.children,j=C(R,g),se=D[j],re=(se||K)._modify(i,h,R+o,m,g,L,w);if(se===re)return this;var ve=ge(i,this),pe=void 0;if(X(se)&&!X(re))++N,pe=E(ve,j,re,D);else if(!X(se)&&X(re)){if(--N,N<=l)return le(i,N,j,D);pe=E(ve,j,K,D)}else pe=E(ve,j,re,D);return ve?(this.size=N,this.children=pe,this):de(i,N,pe)};K._modify=function(c,i,h,R,m,g,L){var w=R();return w===u?K:(++L.value,ae(c,m,g,w))};function d(c,i,h,R,m){this._editable=c,this._edit=i,this._config=h,this._root=R,this._size=m}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var _=n.tryGetHash=function(c,i,h,R){for(var m=R._root,g=0,L=R._config.keyEq;;)switch(m.type){case A:return L(h,m.key)?m.value:c;case P:{if(i===m.hash)for(var w=m.children,N=0,D=w.length;N<D;++N){var j=w[N];if(L(h,j.key))return j.value}return c}case Q:{var se=C(g,i),re=V(se);if(m.mask&re){m=m.children[y(m.mask,re)],g+=o;break}return c}case z:{if(m=m.children[C(g,i)],m){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return _(c,i,h,this)};var S=n.tryGet=function(c,i,h){return _(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return _(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return _(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return _(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var B=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return B(c,this)};var k=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||k,hash:c&&c.hash||v},K,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!X(c._root)};d.prototype.isEmpty=function(){return T(this)};var H=n.modifyHash=function(c,i,h,R){var m={value:R._size},g=R._root._modify(R._editable?R._edit:NaN,R._config.keyEq,0,c,i,h,m);return R.setTree(g,m.value)};d.prototype.modifyHash=function(c,i,h){return H(h,c,i,this)};var ne=n.modify=function(c,i,h){return H(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return ne(i,c,this)};var F=n.setHash=function(c,i,h,R){return H(f(h),c,i,R)};d.prototype.setHash=function(c,i,h){return F(c,i,h,this)};var J=n.set=function(c,i,h){return F(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return J(c,i,this)};var _e=f(u),Ne=n.removeHash=function(c,i,h){return H(_e,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return Ne(c,i,this)};var he=n.remove=function(c,i){return Ne(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return he(c,this)};var ue=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return ue(this)};var An=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return An(this)};var pr=n.mutate=function(c,i){var h=ue(i);return c(h),An(h)};d.prototype.mutate=function(c){return pr(c,this)};var Ft=function(i){return i&&En(i[0],i[1],i[2],i[3],i[4])},En=function(i,h,R,m,g){for(;R<i;){var L=h[R++];if(L&&!X(L))return wn(L,m,[i,h,R,m,g])}return Ft(g)},wn=function(i,h,R){switch(i.type){case A:return{value:h(i),rest:R};case P:case z:case Q:var m=i.children;return En(m.length,m,0,h,R);default:return Ft(R)}},Sr={done:!0};function zt(c){this.v=c}zt.prototype.next=function(){if(!this.v)return Sr;var c=this.v;return this.v=Ft(c.rest),c},zt.prototype[Symbol.iterator]=function(){return this};var Wt=function(i,h){return new zt(wn(i._root,h))},Rr=function(i){return[i.key,i.value]},mr=n.entries=function(c){return Wt(c,Rr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return mr(this)};var yr=function(i){return i.key},gr=n.keys=function(c){return Wt(c,yr)};d.prototype.keys=function(){return gr(this)};var br=function(i){return i.value},Tr=n.values=d.prototype.values=function(c){return Wt(c,br)};d.prototype.values=function(){return Tr(this)};var Nn=n.fold=function(c,i,h){var R=h._root;if(R.type===A)return c(i,R.value,R.key);for(var m=[R.children],g=void 0;g=m.pop();)for(var L=0,w=g.length;L<w;){var N=g[L++];N&&N.type&&(N.type===A?i=c(i,N.value,N.key):m.push(N.children))}return i};d.prototype.fold=function(c,i){return Nn(c,i,this)};var Ar=n.forEach=function(c,i){return Nn(function(h,R,m){return c(R,m,i)},null,i)};d.prototype.forEach=function(c){return Ar(c,this)};var Er=n.count=function(c){return c._size};d.prototype.count=function(){return Er(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class _a{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._map)}}class dn{constructor(t){if(M(this,"_hamt",va.empty.beginMutation()),t instanceof dn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._hamt)}}function fn(e){return W("recoil_hamt_2020")?new dn(e):new _a(e)}var pa={persistentMap:fn},Sa=pa.persistentMap,Ra=Object.freeze({__proto__:null,persistentMap:Sa});function ma(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var et=ma;function ya(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var Rt=ya;function ga(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ba(e){return{nodeDeps:Rt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:Rt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function jt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:et(t,s);for(const u of l)a.has(u)||a.set(u,new Set),q(a.get(u)).add(e);if(s){const u=et(s,t);for(const f of u){if(!a.has(f))return;const v=q(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function Ta(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(jt(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const p=n.getGraph(u.currentTree.version);jt(e,t,p,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var v;const p=(v=u.nextTree)===null||v===void 0?void 0:v.version;if(p!==void 0){const C=n.getGraph(p);jt(e,t,C,f)}}}var st={cloneGraph:ba,graph:ga,saveDepsToStore:Ta};let Aa=0;const Ea=()=>Aa++;let wa=0;const Na=()=>wa++;let La=0;const Va=()=>La++;var wt={getNextTreeStateVersion:Ea,getNextStoreID:Na,getNextComponentID:Va};const{persistentMap:Ln}=Ra,{graph:Ca}=st,{getNextTreeStateVersion:io}=wt;function co(){const e=io();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ln(),nonvalidatedAtoms:Ln()}}function $a(){const e=co();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Ca()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var lo={makeEmptyTreeState:co,makeEmptyStoreState:$a,getNextTreeStateVersion:io};class uo{}function Ma(){return new uo}var Nt={RetentionZone:uo,retentionZone:Ma};function Ua(e,t){const n=new Set(e);return n.add(t),n}function Ia(e,t){const n=new Set(e);return n.delete(t),n}function Da(e,t,n){const o=new Map(e);return o.set(t,n),o}function ka(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Ba(e,t){const n=new Map(e);return n.delete(t),n}function Pa(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var fo={setByAddingToSet:Ua,setByDeletingFromSet:Ia,mapBySettingInMap:Da,mapByUpdatingInMap:ka,mapByDeletingFromMap:Ba,mapByDeletingMultipleFromMap:Pa};function*Oa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var hn=Oa;function xa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var ho=xa;const{getNode:it,getNodeMaybe:Fa,recoilValuesForKeys:Vn}=ce,{RetentionZone:Cn}=Nt,{setByAddingToSet:za}=fo,Wa=Object.freeze(new Set);class Ga extends Error{}function Ka(e,t,n){if(!W("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Cn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!W("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u==null||u.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Cn)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function vn(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=it(n),s=Ka(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function Ha(e,t,n){vn(e,e.getState().currentTree,t,n)}function ja(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function qa(e,t,n){return vn(e,t,n,"get"),it(n).get(e,t)}function vo(e,t,n){return it(n).peek(e,t)}function Za(e,t,n){var o;const r=Fa(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:za(e.dirtyAtoms,t)}}function Ya(e,t,n,o){const r=it(n);if(r.set==null)throw new Ga(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return vn(e,t,n,"set"),a(e,t,o)}function Xa(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=it(n).nodeType;return ho({type:a},{loadable:()=>vo(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return Vn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:Vn(hn(_o(e,t,new Set([n])),u=>u!==n)),components:Et((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function _o(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:Wa;for(const f of u)o.has(f)||r.push(f)}return o}var Ae={getNodeLoadable:qa,peekNodeLoadable:vo,setNodeValue:Ya,initializeNode:Ha,cleanUpNode:ja,setUnvalidatedAtomValue_DEPRECATED:Za,peekNodeInfo:Xa,getDownstreamNodes:_o};let po=null;function Ja(e){po=e}function Qa(){var e;(e=po)===null||e===void 0||e()}var So={setInvalidateMemoizedSnapshot:Ja,invalidateMemoizedSnapshot:Qa};const{getDownstreamNodes:es,getNodeLoadable:Ro,setNodeValue:ts}=Ae,{getNextComponentID:ns}=wt,{getNode:os,getNodeMaybe:mo}=ce,{DefaultValue:_n}=ce,{reactMode:rs}=at,{AbstractRecoilValue:as,RecoilState:ss,RecoilValueReadOnly:is,isRecoilValue:cs}=xe,{invalidateMemoizedSnapshot:ls}=So;function us(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=Ro(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function ds(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof _n?n.delete(r):n.set(r,o)}),n}function fs(e,t,{key:n},o){if(typeof o=="function"){const r=Ro(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw U(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function hs(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=fs(e,t,r,a),l=ts(e,t,r.key,s);for(const[u,f]of l.entries())Qt(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Qt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=mo(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else cn(`Unknown action ${n.type}`)}function Qt(e,t,n){n.state==="hasValue"&&n.contents instanceof _n?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function yo(e,t){e.replaceState(n=>{const o=go(n);for(const r of t)hs(e,o,r);return bo(e,o),ls(),o})}function Lt(e,t){if(tt.length){const n=tt[tt.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else yo(e,[t])}const tt=[];function vs(){const e=new Map;return tt.push(e),()=>{for(const[t,n]of e)yo(t,n);tt.pop()}}function go(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function bo(e,t){const n=es(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=mo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function To(e,t,n){Lt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function _s(e,t,n){if(n instanceof _n)return To(e,t,n);Lt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function ps(e,t){Lt(e,{type:"markModified",recoilValue:t})}function Ss(e,t,n){Lt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Rs(e,{key:t},n,o=null){const r=ns(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),q(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=rs();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function ms(e,t){var n;const{currentTree:o}=e.getState(),r=os(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Re={RecoilValueReadOnly:is,AbstractRecoilValue:as,RecoilState:ss,getRecoilValueAsLoadable:us,setRecoilValue:To,setRecoilValueLoadable:_s,markRecoilValueModified:ps,setUnvalidatedRecoilValue:Ss,subscribeToRecoilValue:Rs,isRecoilValue:cs,applyAtomValueWrites:ds,batchStart:vs,writeLoadableToTreeState:Qt,invalidateDownstreams:bo,copyTreeState:go,refreshRecoilValue:ms};function ys(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var gs=ys;const{cleanUpNode:bs}=Ae,{deleteNodeConfigIfPossible:Ts,getNode:Ao}=ce,{RetentionZone:Eo}=Nt,As=12e4,wo=new Set;function No(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof Eo)for(const l of Ls(n,s))r.add(l);else r.add(s);const a=Es(e,r);for(const s of a)Ns(e,o,s)}function Es(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,v=ws(e,o,u,a,s);for(const y of v){var p;if(Ao(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((p=n.retention.referenceCounts.get(y))!==null&&p!==void 0?p:0)>0){s.add(y);continue}if(Lo(y).some(Y=>n.retention.referenceCounts.get(Y))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&gs(E,Y=>s.has(Y))){s.add(y);continue}a.add(y),f.add(y)}const C=new Set;for(const y of f)for(const E of(V=r.nodeDeps.get(y))!==null&&V!==void 0?V:wo){var V;a.has(E)||C.add(E)}C.size&&l(C)}}function ws(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(q(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const p of v)u(p);l.add(f),n.delete(f),s.push(f)}}function Ns(e,t,n){if(!W("recoil_memory_managament_2020"))return;bs(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=Lo(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Ts(n)}function Ls(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:wo}function Lo(e){const t=Ao(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Eo?[t]:t}function Vs(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):No(e,new Set([t]))}function Cs(e,t,n){var o;if(!W("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Vo(e,t):r.set(t,a)}function Vo(e,t){if(!W("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Vs(e,t)}function $s(e){if(!W("recoil_memory_managament_2020"))return;const t=e.getState();No(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ms(e){return e===void 0?"recoilRoot":e}var Me={SUSPENSE_TIMEOUT_MS:As,updateRetainCount:Cs,updateRetainCountToZero:Vo,releaseScheduledRetainablesNow:$s,retainedByOptionWithDefault:Ms};const{unstable_batchedUpdates:Us}=wr;var Is={unstable_batchedUpdates:Us};const{unstable_batchedUpdates:Ds}=Is;var ks={unstable_batchedUpdates:Ds};const{batchStart:Bs}=Re,{unstable_batchedUpdates:Ps}=ks;let pn=Ps||(e=>e());const Os=e=>{pn=e},xs=()=>pn,Fs=e=>{pn(()=>{let t=()=>{};try{t=Bs(),e()}finally{t()}})};var Vt={getBatcher:xs,setBatcher:Os,batchUpdates:Fs};function*zs(e){for(const t of e)for(const n of t)yield n}var Co=zs;const $o=typeof Window>"u"||typeof window>"u",Ws=e=>!$o&&(e===window||e instanceof Window),Gs=typeof navigator<"u"&&navigator.product==="ReactNative";var Ct={isSSR:$o,isReactNative:Gs,isWindow:Ws};function Ks(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function Hs(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function js(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var qs={memoizeWithArgsHash:Ks,memoizeOneWithArgsHash:Hs,memoizeOneWithArgsHashAndInvalidation:js};const{batchUpdates:en}=Vt,{initializeNode:Zs,peekNodeInfo:Ys}=Ae,{graph:Xs}=st,{getNextStoreID:Js}=wt,{DEFAULT_VALUE:Qs,recoilValues:$n,recoilValuesForKeys:Mn}=ce,{AbstractRecoilValue:ei,getRecoilValueAsLoadable:ti,setRecoilValue:Un,setUnvalidatedRecoilValue:ni}=Re,{updateRetainCount:pt}=Me,{setInvalidateMemoizedSnapshot:oi}=So,{getNextTreeStateVersion:ri,makeEmptyStoreState:ai}=lo,{isSSR:si}=Ct,{memoizeOneWithArgsHashAndInvalidation:ii}=qs;class $t{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ti(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return Mn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?$n.values():o.isInitialized===!0?Mn(Co([r,a])):hn($n.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),Ys(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:Js(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return q(r.get(o));const a=Xs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw U("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)Zs(this._store,o,"get"),pt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){si||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!W("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){W("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function Mo(e,t,n=!1){const o=e.getState(),r=n?ri():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Et(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ci(e){const t=new $t(ai());return e!=null?t.map(e):t}const[In,Uo]=ii((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:q(o.previousTree);return new $t(Mo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});oi(Uo);function li(e,t="latest"){const n=In(e,t);return n.isRetained()?n:(Uo(),In(e,t))}class tn extends $t{constructor(t,n){super(Mo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{pt(a,o.key,1),Un(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{pt(r,o.key,1),Un(this.getStore_INTERNAL(),o,Qs)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();en(()=>{for(const[a,s]of o.entries())pt(r,a,1),ni(r,new ei(a),s)})}),this._batch=n}}var Mt={Snapshot:$t,MutableSnapshot:tn,freshSnapshot:ci,cloneSnapshot:li},ui=Mt.Snapshot,di=Mt.MutableSnapshot,fi=Mt.freshSnapshot,hi=Mt.cloneSnapshot,Ut=Object.freeze({__proto__:null,Snapshot:ui,MutableSnapshot:di,freshSnapshot:fi,cloneSnapshot:hi});function vi(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var _i=vi;const{useRef:pi}=Z;function Si(e){const t=pi(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var Dn=Si;const{getNextTreeStateVersion:Ri,makeEmptyStoreState:Io}=lo,{cleanUpNode:mi,getDownstreamNodes:yi,initializeNode:gi,setNodeValue:bi,setUnvalidatedAtomValue_DEPRECATED:Ti}=Ae,{graph:Ai}=st,{cloneGraph:Ei}=st,{getNextStoreID:Do}=wt,{createMutableSource:qt,reactMode:ko}=at,{applyAtomValueWrites:wi}=Re,{releaseScheduledRetainablesNow:Bo}=Me,{freshSnapshot:Ni}=Ut,{useCallback:Li,useContext:Po,useEffect:nn,useMemo:Vi,useRef:Ci,useState:$i}=Z;function qe(){throw U("This component must be used inside a <RecoilRoot> component.")}const Oo=Object.freeze({storeID:Do(),getState:qe,replaceState:qe,getGraph:qe,subscribeToTransactions:qe,addTransactionMetadata:qe});let on=!1;function kn(e){if(on)throw U("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){W("recoil_memory_managament_2020")&&W("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Bo(e);const n=t.currentTree.version,o=Ri();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ei(q(t.graphsByVersion.get(n))))}}const xo=Z.createContext({current:Oo}),It=()=>Po(xo),Fo=Z.createContext(null);function Mi(){return Po(Fo)}function Sn(e,t,n){const o=yi(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function zo(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!ko().early||t.suspendedComponentResolvers.size>0)&&(Sn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ui(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,zo(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):cn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,W("recoil_memory_managament_2020")&&n==null&&Bo(e)}finally{t.commitDepth--}}function Ii({setNotifyBatcherOfChange:e}){const t=It(),[,n]=$i([]);return e(()=>n({})),nn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),nn(()=>{fa.enqueueExecution("Batcher",()=>{Ui(t.current)})}),null}function Di(e,t){const n=Io();return t({set:(o,r)=>{const a=n.currentTree,s=bi(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:_i(a.dirtyAtoms,l),atomValues:wi(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Ti(n.currentTree,a,r)})}}),n}function ki(e){const t=Ni(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let Bn=0;function Bi({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=V=>{const y=r.current.graphsByVersion;if(y.has(V))return q(y.get(V));const E=Ai();return y.set(V,E),E},s=(V,y)=>{if(y==null){const{transactionSubscriptions:E}=p.current.getState(),Y=Bn++;return E.set(Y,V),{release:()=>{E.delete(Y)}}}else{const{nodeTransactionSubscriptions:E}=p.current.getState();E.has(y)||E.set(y,new Map);const Y=Bn++;return q(E.get(y)).set(Y,V),{release:()=>{const oe=E.get(y);oe&&(oe.delete(Y),oe.size===0&&E.delete(y))}}}},l=V=>{kn(p.current);for(const y of Object.keys(V))q(p.current.getState().nextTree).transactionMetadata[y]=V[y]},u=V=>{kn(p.current);const y=q(r.current.nextTree);let E;try{on=!0,E=V(y)}finally{on=!1}E!==y&&(r.current.nextTree=E,ko().early&&Sn(p.current,r.current,E),q(f.current)())},f=Ci(null),v=Li(V=>{f.current=V},[f]),p=Dn(()=>n??{storeID:Do(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(p.current=n),r=Dn(()=>e!=null?Di(p.current,e):t!=null?ki(t):Io());const C=Vi(()=>qt==null?void 0:qt(r,()=>r.current.currentTree.version),[r]);return nn(()=>{const V=p.current;for(const y of new Set(V.getState().knownAtoms))gi(V,y,"get");return()=>{for(const y of V.getState().knownAtoms)mi(V,y)}},[p]),Z.createElement(xo.Provider,{value:p},Z.createElement(Fo.Provider,{value:C},Z.createElement(Ii,{setNotifyBatcherOfChange:v}),o))}function Pi(e){const{override:t,...n}=e,o=It();return t===!1&&o.current!==Oo?e.children:Z.createElement(Bi,n)}function Oi(){return It().current.storeID}var be={RecoilRoot:Pi,useStoreRef:It,useRecoilMutableSource:Mi,useRecoilStoreID:Oi,notifyComponents_FOR_TESTING:Sn,sendEndOfBatchNotifications_FOR_TESTING:zo};function xi(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var Fi=xi;const{useEffect:zi,useRef:Wi}=Z;function Gi(e){const t=Wi();return zi(()=>{t.current=e}),t.current}var Wo=Gi;const{useStoreRef:Ki}=be,{SUSPENSE_TIMEOUT_MS:Hi}=Me,{updateRetainCount:Ze}=Me,{RetentionZone:ji}=Nt,{useEffect:qi,useRef:Zi}=Z,{isSSR:Pn}=Ct;function Yi(e){if(W("recoil_memory_managament_2020"))return Xi(e)}function Xi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof ji?s:s.key),o=Ki();qi(()=>{if(!W("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Pn)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(s,l,1);return()=>{for(const l of n)Ze(s,l,-1)}},[o,...n]);const r=Zi(),a=Wo(n);if(!Pn&&(a===void 0||!Fi(a,n))){const s=o.current;for(const l of n)Ze(s,l,1);if(a)for(const l of a)Ze(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(s,l,-1)},Hi)}}var Rn=Yi;function Ji(){return"<component name not available>"}var ct=Ji;const{batchUpdates:Qi}=Vt,{DEFAULT_VALUE:Go}=ce,{currentRendererSupportsUseSyncExternalStore:ec,reactMode:Ke,useMutableSource:tc,useSyncExternalStore:nc}=at,{useRecoilMutableSource:oc,useStoreRef:me}=be,{AbstractRecoilValue:rn,getRecoilValueAsLoadable:lt,setRecoilValue:mt,setUnvalidatedRecoilValue:rc,subscribeToRecoilValue:Fe}=Re,{useCallback:ie,useEffect:ze,useMemo:Ko,useRef:nt,useState:mn}=Z,{setByAddingToSet:ac}=fo,{isSSR:sc}=Ct;function yn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),sc&&G(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:U(`Invalid value of loadable atom "${t.key}"`)}function ic(){const e=ct(),t=me(),[,n]=mn([]),o=nt(new Set);o.current=new Set;const r=nt(new Set),a=nt(new Map),s=ie(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ie((u,f)=>{a.current.has(f)&&n([])},[]);return ze(()=>{const u=t.current;et(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const v=Fe(u,new rn(f),C=>l(C,f),e);a.current.set(f,v),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),et(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),ze(()=>{const u=a.current;return et(o.current,new Set(u.keys())).forEach(f=>{const v=Fe(t.current,new rn(f),p=>l(p,f),e);u.set(f,v)}),()=>u.forEach((f,v)=>s(v))},[e,t,s,l]),Ko(()=>{function u(y){return E=>{mt(t.current,y,E)}}function f(y){return()=>mt(t.current,y,Go)}function v(y){var E;o.current.has(y.key)||(o.current=ac(o.current,y.key));const Y=t.current.getState();return lt(t.current,y,Ke().early&&(E=Y.nextTree)!==null&&E!==void 0?E:Y.currentTree)}function p(y){const E=v(y);return yn(E,y,t)}function C(y){return[p(y),u(y)]}function V(y){return[v(y),u(y)]}return{getRecoilValue:p,getRecoilValueLoadable:v,getRecoilState:C,getRecoilStateLoadable:V,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const cc={current:0};function lc(e){const t=me(),n=ct(),o=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:lt(u,e,v),key:e.key}},[t,e]),r=ie(l=>{let u;return()=>{var f,v;const p=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(p.loadable)&&((v=u)===null||v===void 0?void 0:v.key)===p.key?u:(u=p,p)}},[]),a=Ko(()=>r(o),[o,r]),s=ie(l=>{const u=t.current;return Fe(u,e,l,n).release},[t,e,n]);return nc(s,a,a).loadable}function uc(e){const t=me(),n=ie(()=>{var f;const v=t.current,p=v.getState(),C=Ke().early&&(f=p.nextTree)!==null&&f!==void 0?f:p.currentTree;return lt(v,e,C)},[t,e]),o=ie(()=>n(),[n]),r=ct(),a=ie((f,v)=>{const p=t.current;return Fe(p,e,()=>{if(!W("recoil_suppress_rerender_in_callback"))return v();const V=n();u.current.is(V)||v(),u.current=V},r).release},[t,e,r,n]),s=oc();if(s==null)throw U("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=tc(s,o,a),u=nt(l);return ze(()=>{u.current=l}),l}function an(e){const t=me(),n=ct(),o=ie(()=>{var u;const f=t.current,v=f.getState(),p=Ke().early&&(u=v.nextTree)!==null&&u!==void 0?u:v.currentTree;return lt(f,e,p)},[t,e]),r=ie(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ie(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);ze(()=>{const u=Fe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=mn(r);return s.key!==e.key?r().loadable:s.loadable}function dc(e){const t=me(),[,n]=mn([]),o=ct(),r=ie(()=>{var l;const u=t.current,f=u.getState(),v=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return lt(u,e,v)},[t,e]),a=r(),s=nt(a);return ze(()=>{s.current=a}),ze(()=>{const l=t.current,u=l.getState(),f=Fe(l,e,p=>{var C;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const V=r();(C=s.current)!==null&&C!==void 0&&C.is(V)||n(V),s.current=V},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const p=r();(v=s.current)!==null&&v!==void 0&&v.is(p)||n(p),s.current=p}return f.release},[o,r,e,t]),a}function gn(e){return W("recoil_memory_managament_2020")&&Rn(e),{TRANSITION_SUPPORT:an,SYNC_EXTERNAL_STORE:ec()?lc:an,MUTABLE_SOURCE:uc,LEGACY:dc}[Ke().mode](e)}function Ho(e){const t=me(),n=gn(e);return yn(n,e,t)}function Dt(e){const t=me();return ie(n=>{mt(t.current,e,n)},[t,e])}function fc(e){const t=me();return ie(()=>{mt(t.current,e,Go)},[t,e])}function hc(e){return[Ho(e),Dt(e)]}function vc(e){return[gn(e),Dt(e)]}function _c(){const e=me();return(t,n={})=>{Qi(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>rc(e.current,new rn(r),o))})}}function jo(e){return W("recoil_memory_managament_2020")&&Rn(e),an(e)}function qo(e){const t=me(),n=jo(e);return yn(n,e,t)}function pc(e){return[qo(e),Dt(e)]}var Sc={recoilComponentGetRecoilValueCount_FOR_TESTING:cc,useRecoilInterface:ic,useRecoilState:hc,useRecoilStateLoadable:vc,useRecoilValue:Ho,useRecoilValueLoadable:gn,useResetRecoilState:fc,useSetRecoilState:Dt,useSetUnvalidatedAtomValues:_c,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:jo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:qo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:pc};function Rc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var mc=Rc;function yc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var gc=yc;function bc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Tc=bc;const{batchUpdates:Ac}=Vt,{DEFAULT_VALUE:Ec,getNode:Zo,nodes:wc}=ce,{useStoreRef:bn}=be,{AbstractRecoilValue:Nc,setRecoilValueLoadable:Lc}=Re,{SUSPENSE_TIMEOUT_MS:Vc}=Me,{cloneSnapshot:yt}=Ut,{useCallback:kt,useEffect:Yo,useRef:On,useState:Cc}=Z,{isSSR:xn}=Ct;function Bt(e){const t=bn();Yo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Fn(e){const t=e.atomValues.toMap(),n=Rt(mc(t,(o,r)=>{const s=Zo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Tc(e.nonvalidatedAtoms.toMap(),n)}function $c(e){Bt(kt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Fn(o),a=Fn(n),s=Rt(wc,u=>{var f,v,p,C;return{persistence_UNSTABLE:{type:(f=(v=u.persistence_UNSTABLE)===null||v===void 0?void 0:v.type)!==null&&f!==void 0?f:"none",backButton:(p=(C=u.persistence_UNSTABLE)===null||C===void 0?void 0:C.backButton)!==null&&p!==void 0?p:!1}}}),l=gc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Mc(e){Bt(kt(t=>{const n=yt(t,"latest"),o=yt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Uc(){const e=bn(),[t,n]=Cc(()=>yt(e.current)),o=Wo(t),r=On(),a=On();if(Bt(kt(l=>n(yt(l)),[])),Yo(()=>{const l=t.retain();if(r.current&&!xn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!xn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Vc)}return t}function Xo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Ac(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var l,u;((l=r.atomValues.get(v))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(v))===null||u===void 0?void 0:u.contents)&&Zo(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{Lc(e,new Nc(f),a.atomValues.has(f)?q(a.atomValues.get(f)):Ec)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Ic(){const e=bn();return kt(t=>Xo(e.current,t),[e])}var Jo={useRecoilSnapshot:Uc,gotoSnapshot:Xo,useGotoRecoilSnapshot:Ic,useRecoilTransactionObserver:Mc,useTransactionObservation_DEPRECATED:$c,useTransactionSubscription_DEPRECATED:Bt};const{peekNodeInfo:Dc}=Ae,{useStoreRef:kc}=be;function Bc(){const e=kc();return({key:t})=>Dc(e.current,e.current.getState().currentTree,t)}var Pc=Bc;const{reactMode:Oc}=at,{RecoilRoot:xc,useStoreRef:Fc}=be,{useMemo:zc}=Z;function Wc(){Oc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=Fc().current;return zc(()=>{function t({children:n}){return Z.createElement(xc,{store_INTERNAL:e},n)}return t},[e])}var Gc=Wc;const{loadableWithValue:Kc}=rt,{initializeNode:Hc}=Ae,{DEFAULT_VALUE:jc,getNode:qc}=ce,{copyTreeState:Zc,getRecoilValueAsLoadable:Yc,invalidateDownstreams:Xc,writeLoadableToTreeState:Jc}=Re;function zn(e){return qc(e.key).nodeType==="atom"}class Qc{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!zn(o))throw U("Reading selectors within atomicUpdate is not supported");const r=Yc(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:U(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!zn(o))throw U("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Hc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,jc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Zc(this._treeState);for(const[n,o]of this._changes)Jc(t,n,Kc(o));return Xc(this._store,t),t}}function el(e){return t=>{e.replaceState(n=>{const o=new Qc(e,n);return t(o),o.newTreeState_INTERNAL()})}}var tl={atomicUpdater:el},nl=tl.atomicUpdater,Qo=Object.freeze({__proto__:null,atomicUpdater:nl});function ol(e,t){if(!e)throw new Error(t)}var rl=ol,Qe=rl;const{atomicUpdater:al}=Qo,{batchUpdates:sl}=Vt,{DEFAULT_VALUE:il}=ce,{useStoreRef:cl}=be,{refreshRecoilValue:ll,setRecoilValue:Wn}=Re,{cloneSnapshot:ul}=Ut,{gotoSnapshot:dl}=Jo,{useCallback:fl}=Z;class er{}const hl=new er;function tr(e,t,n,o){let r=hl,a;if(sl(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw U(l);const u=ho({...o??{},set:(v,p)=>Wn(e,v,p),reset:v=>Wn(e,v,il),refresh:v=>ll(e,v),gotoSnapshot:v=>dl(e,v),transact_UNSTABLE:v=>al(e)(v)},{snapshot:()=>{const v=ul(e);return a=v.retain(),v}}),f=t(u);if(typeof f!="function")throw U(l);r=f(...n)}),r instanceof er&&Qe(!1),G(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function vl(e,t){const n=cl();return fl((...o)=>tr(n.current,e,o),t!=null?[...t,n]:void 0)}var nr={recoilCallback:tr,useRecoilCallback:vl};const{useStoreRef:_l}=be,{refreshRecoilValue:pl}=Re,{useCallback:Sl}=Z;function Rl(e){const t=_l();return Sl(()=>{const n=t.current;pl(n,e)},[e,t])}var ml=Rl;const{atomicUpdater:yl}=Qo,{useStoreRef:gl}=be,{useMemo:bl}=Z;function Tl(e,t){const n=gl();return bl(()=>(...o)=>{yl(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Al=Tl;class El{constructor(t){M(this,"value",void 0),this.value=t}}var wl={WrappedValue:El},Nl=wl.WrappedValue,or=Object.freeze({__proto__:null,WrappedValue:Nl});const{isFastRefreshEnabled:Ll}=at;class Gn extends Error{}class Vl{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,v;for(const[Y,oe]of t){var p,C,V;const A=this._root;if((A==null?void 0:A.type)==="leaf")throw this.invalidCacheError();const P=f;if(f=P?P.branches.get(v):A,f=(p=f)!==null&&p!==void 0?p:{type:"branch",nodeKey:Y,parent:P,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Y)throw this.invalidCacheError();P==null||P.branches.set(v,f),o==null||(C=o.onNodeVisit)===null||C===void 0||C.call(o,f),v=this._mapNodeValue(oe),this._root=(V=this._root)!==null&&V!==void 0?V:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==v))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Gn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Ll()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw cn(t+(this._name!=null?` - ${this._name}`:"")),new Gn}}var Cl={TreeCache:Vl},$l=Cl.TreeCache,rr=Object.freeze({__proto__:null,TreeCache:$l});class Ml{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=q(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var Ul={LRUCache:Ml},Il=Ul.LRUCache,ar=Object.freeze({__proto__:null,LRUCache:Il});const{LRUCache:Dl}=ar,{TreeCache:kl}=rr;function Bl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new Dl({maxSize:t}),r=new kl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var Kn=Bl;function Se(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw U("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(G(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>Se(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return Se(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:Se(a,t)]=s;return Se(r,t,n)}return e instanceof Set?Se(Array.from(e).sort((r,a)=>Se(r,t).localeCompare(Se(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?Se(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${Se(r,t)}:${Se(e[r],t,r)}`).join(",")}}`}function Pl(e,t={allowFunctions:!1}){return Se(e,t)}var Pt=Pl;const{TreeCache:Ol}=rr,dt={equality:"reference",eviction:"keep-all",maxSize:1/0};function xl({equality:e=dt.equality,eviction:t=dt.eviction,maxSize:n=dt.maxSize}=dt,o){const r=Fl(e);return zl(t,n,r,o)}function Fl(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw U(`Unrecognized equality policy ${e}`)}function zl(e,t,n,o){switch(e){case"keep-all":return new Ol({name:o,mapNodeValue:n});case"lru":return Kn({name:o,maxSize:q(t),mapNodeValue:n});case"most-recent":return Kn({name:o,maxSize:1,mapNodeValue:n})}throw U(`Unrecognized eviction policy ${e}`)}var Wl=xl;function Gl(e){return()=>null}var Kl={startPerfBlock:Gl};const{isLoadable:Hl,loadableWithError:ft,loadableWithPromise:jl,loadableWithValue:Zt}=rt,{WrappedValue:sr}=or,{getNodeLoadable:ht,peekNodeLoadable:ql,setNodeValue:Zl}=Ae,{saveDepsToStore:Yl}=st,{DEFAULT_VALUE:Xl,getConfigDeletionHandler:Jl,getNode:Ql,registerNode:Hn}=ce,{isRecoilValue:eu}=xe,{markRecoilValueModified:jn}=Re,{retainedByOptionWithDefault:tu}=Me,{recoilCallback:nu}=nr,{startPerfBlock:ou}=Kl;class ir{}const Ye=new ir,Xe=[],vt=new Map,ru=(()=>{let e=0;return()=>e++})();function cr(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=Wl(r??{equality:"reference",eviction:"keep-all"},n),u=tu(e.retainedBy_UNSTABLE),f=new Map;let v=0;function p(){return!W("recoil_memory_managament_2020")||v>0}function C(d){return d.getState().knownSelectors.add(n),v++,()=>{v--}}function V(){return Jl(n)!==void 0&&!p()}function y(d,_,S,$,b){fe(_,$,b),E(d,S)}function E(d,_){le(d,_)&&ee(d),oe(_,!0)}function Y(d,_){le(d,_)&&(q(te(d)).stateVersions.clear(),oe(_,!1))}function oe(d,_){const S=vt.get(d);if(S!=null){for(const $ of S)jn($,q(t));_&&vt.delete(d)}}function A(d,_){let S=vt.get(_);S==null&&vt.set(_,S=new Set),S.add(d)}function P(d,_,S,$,b,B){return _.then(k=>{if(!p())throw ee(d),Ye;const T=Zt(k);return y(d,S,b,T,$),k}).catch(k=>{if(!p())throw ee(d),Ye;if(G(k))return Q(d,k,S,$,b,B);const T=ft(k);throw y(d,S,b,T,$),k})}function Q(d,_,S,$,b,B){return _.then(k=>{if(!p())throw ee(d),Ye;B.loadingDepKey!=null&&B.loadingDepPromise===_?S.atomValues.set(B.loadingDepKey,Zt(k)):d.getState().knownSelectors.forEach(F=>{S.atomValues.delete(F)});const T=X(d,S);if(T&&T.state!=="loading"){if((le(d,b)||te(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!le(d,b)){const F=ye(d,S);if(F!=null)return F.loadingLoadable.contents}const[H,ne]=K(d,S,b);if(H.state!=="loading"&&y(d,S,b,H,ne),H.state==="hasError")throw H.contents;return H.contents}).catch(k=>{if(k instanceof ir)throw Ye;if(!p())throw ee(d),Ye;const T=ft(k);throw y(d,S,b,T,$),k})}function z(d,_,S,$){var b,B,k,T;if(le(d,$)||_.version===((b=d.getState())===null||b===void 0||(B=b.currentTree)===null||B===void 0?void 0:B.version)||_.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var H,ne,F;Yl(n,S,d,(H=(ne=d.getState())===null||ne===void 0||(F=ne.nextTree)===null||F===void 0?void 0:F.version)!==null&&H!==void 0?H:d.getState().currentTree.version)}for(const J of S)s.add(J)}function K(d,_,S){const $=ou(n);let b=!0,B=!0;const k=()=>{$(),B=!1};let T,H=!1,ne;const F={loadingDepKey:null,loadingDepPromise:null},J=new Map;function _e({key:he}){const ue=ht(d,_,he);switch(J.set(he,ue),b||(z(d,_,new Set(J.keys()),S),Y(d,S)),ue.state){case"hasValue":return ue.contents;case"hasError":throw ue.contents;case"loading":throw F.loadingDepKey=he,F.loadingDepPromise=ue.contents,ue.contents}throw U("Invalid Loadable state")}const Ne=he=>(...ue)=>{if(B)throw U("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Qe(!1),nu(d,he,ue,{node:t})};try{T=o({get:_e,getCallback:Ne}),T=eu(T)?_e(T):T,Hl(T)&&(T.state==="hasError"&&(H=!0),T=T.contents),G(T)?T=P(d,T,_,J,S,F).finally(k):k(),T=T instanceof sr?T.value:T}catch(he){T=he,G(T)?T=Q(d,T,_,J,S,F).finally(k):(H=!0,k())}return H?ne=ft(T):G(T)?ne=jl(T):ne=Zt(T),b=!1,Ue(d,S,J),z(d,_,new Set(J.keys()),S),[ne,J]}function X(d,_){let S=_.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(B=>(typeof B!="string"&&Qe(!1),ht(d,_,B).contents),{onNodeVisit:B=>{B.type==="branch"&&B.nodeKey!==n&&$.add(B.nodeKey)}})}catch(B){throw U(`Problem with cache lookup for selector "${n}": ${B.message}`)}if(S){var b;_.atomValues.set(n,S),z(d,_,$,(b=te(d))===null||b===void 0?void 0:b.executionID)}return S}function ae(d,_){const S=X(d,_);if(S!=null)return ee(d),S;const $=ye(d,_);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&A(d,$.executionID),$.loadingLoadable}const B=ru(),[k,T]=K(d,_,B);return k.state==="loading"?(de(d,B,k,T,_),A(d,B)):(ee(d),fe(_,k,T)),k}function ye(d,_){const S=Co([f.has(d)?[q(f.get(d))]:[],Et(hn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[B,k]of b)if(!ht(d,_,B).is(k))return!0;return!1}for(const b of S){if(b.stateVersions.get(_.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(_.version,!0),b;b.stateVersions.set(_.version,!1)}}function te(d){return f.get(d)}function de(d,_,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:_,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function Ue(d,_,S){if(le(d,_)){const $=te(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function ee(d){f.delete(d)}function le(d,_){var S;return _===((S=te(d))===null||S===void 0?void 0:S.executionID)}function we(d){return Array.from(d.entries()).map(([_,S])=>[_,S.contents])}function fe(d,_,S){d.atomValues.set(n,_);try{l.set(we(S),_)}catch($){throw U(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ge(d){if(Xe.includes(n)){const _=`Recoil selector has circular dependencies: ${Xe.slice(Xe.indexOf(n)).join("  ")}`;return ft(U(_))}Xe.push(n);try{return d()}finally{Xe.pop()}}function Ie(d,_){const S=_.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&Qe(!1),(b=ql(d,_,$))===null||b===void 0?void 0:b.contents})}function De(d,_){return ge(()=>ae(d,_))}function O(d){d.atomValues.delete(n)}function x(d,_){t==null&&Qe(!1);for(const $ of s){var S;const b=Ql($);(S=b.clearCache)===null||S===void 0||S.call(b,d,_)}s.clear(),O(_),l.clear(),jn(d,t)}return a!=null?t=Hn({key:n,nodeType:"selector",peek:Ie,get:De,set:(_,S,$)=>{let b=!1;const B=new Map;function k({key:F}){if(b)throw U("Recoil: Async selector sets are not currently supported.");const J=ht(_,S,F);if(J.state==="hasValue")return J.contents;if(J.state==="loading"){const _e=`Getting value of asynchronous atom or selector "${F}" in a pending state while setting selector "${n}" is not yet supported.`;throw U(_e)}else throw J.contents}function T(F,J){if(b)throw U("Recoil: Async selector sets are not currently supported.");const _e=typeof J=="function"?J(k(F)):J;Zl(_,S,F.key,_e).forEach((he,ue)=>B.set(ue,he))}function H(F){T(F,Xl)}const ne=a({set:T,get:k,reset:H},$);if(ne!==void 0)throw G(ne)?U("Recoil: Async selector sets are not currently supported."):U("Recoil: selector set should be a void function.");return b=!0,B},init:C,invalidate:O,clearCache:x,shouldDeleteConfigOnRelease:V,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=Hn({key:n,nodeType:"selector",peek:Ie,get:De,init:C,invalidate:O,clearCache:x,shouldDeleteConfigOnRelease:V,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}cr.value=e=>new sr(e);var We=cr;const{isLoadable:au,loadableWithError:Yt,loadableWithPromise:Xt,loadableWithValue:Be}=rt,{WrappedValue:lr}=or,{peekNodeInfo:su}=Ae,{DEFAULT_VALUE:Le,DefaultValue:Te,getConfigDeletionHandler:ur,registerNode:iu,setConfigDeletionHandler:cu}=ce,{isRecoilValue:lu}=xe,{getRecoilValueAsLoadable:uu,markRecoilValueModified:du,setRecoilValue:qn,setRecoilValueLoadable:fu}=Re,{retainedByOptionWithDefault:hu}=Me,Je=e=>e instanceof lr?e.value:e;function vu(e){const{key:t,persistence_UNSTABLE:n}=e,o=hu(e.retainedBy_UNSTABLE);let r=0;function a(A){return Xt(A.then(P=>(s=Be(P),P)).catch(P=>{throw s=Yt(P),P}))}let s=G(e.default)?a(e.default):au(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Be(Je(e.default));s.contents;let l;const u=new Map;function f(A){return A}function v(A,P){const Q=P.then(z=>{var K,X;return((X=((K=A.getState().nextTree)!==null&&K!==void 0?K:A.getState().currentTree).atomValues.get(t))===null||X===void 0?void 0:X.contents)===Q&&qn(A,oe,z),z}).catch(z=>{var K,X;throw((X=((K=A.getState().nextTree)!==null&&K!==void 0?K:A.getState().currentTree).atomValues.get(t))===null||X===void 0?void 0:X.contents)===Q&&fu(A,oe,Yt(z)),z});return Q}function p(A,P,Q){var z;r++;const K=()=>{var te;r--,(te=u.get(A))===null||te===void 0||te.forEach(de=>de()),u.delete(A)};if(A.getState().knownAtoms.add(t),s.state==="loading"){const te=()=>{var de;((de=A.getState().nextTree)!==null&&de!==void 0?de:A.getState().currentTree).atomValues.has(t)||du(A,oe)};s.contents.finally(te)}const X=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(X!=null){let te=function(O){if(le&&O.key===t){const x=ee;return x instanceof Te?C(A,P):G(x)?Xt(x.then(d=>d instanceof Te?s.toPromise():d)):Be(x)}return uu(A,O)},de=function(O){return te(O).toPromise()},Ue=function(O){var x;const d=su(A,(x=A.getState().nextTree)!==null&&x!==void 0?x:A.getState().currentTree,O.key);return le&&O.key===t&&!(ee instanceof Te)?{...d,isSet:!0,loadable:te(O)}:d},ee=Le,le=!0,we=!1,fe=null;const ge=O=>x=>{if(le){const d=te(oe),_=d.state==="hasValue"?d.contents:Le;ee=typeof x=="function"?x(_):x,G(ee)&&(ee=ee.then(S=>(fe={effect:O,value:S},S)))}else{if(G(x))throw U("Setting atoms to async values is not implemented.");typeof x!="function"&&(fe={effect:O,value:Je(x)}),qn(A,oe,typeof x=="function"?d=>{const _=Je(x(d));return fe={effect:O,value:_},_}:Je(x))}},Ie=O=>()=>ge(O)(Le),De=O=>x=>{var d;const{release:_}=A.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:B}=S.getState();B||(B=b);const k=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(k.state==="hasValue"){var T,H,ne,F;const J=k.contents,_e=(T=B.atomValues.get(t))!==null&&T!==void 0?T:s,Ne=_e.state==="hasValue"?_e.contents:Le;((H=fe)===null||H===void 0?void 0:H.effect)!==O||((ne=fe)===null||ne===void 0?void 0:ne.value)!==J?x(J,Ne,!b.atomValues.has(t)):((F=fe)===null||F===void 0?void 0:F.effect)===O&&(fe=null)}},t);u.set(A,[...(d=u.get(A))!==null&&d!==void 0?d:[],_])};for(const O of X)try{const x=O({node:oe,storeID:A.storeID,parentStoreID_UNSTABLE:A.parentStoreID,trigger:Q,setSelf:ge(O),resetSelf:Ie(O),onSet:De(O),getPromise:de,getLoadable:te,getInfo_UNSTABLE:Ue});if(x!=null){var ae;u.set(A,[...(ae=u.get(A))!==null&&ae!==void 0?ae:[],x])}}catch(x){ee=x,we=!0}if(le=!1,!(ee instanceof Te)){var ye;const O=we?Yt(ee):G(ee)?Xt(v(A,ee)):Be(Je(ee));O.contents,P.atomValues.set(t,O),(ye=A.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,O)}}return K}function C(A,P){var Q,z;return(Q=(z=P.atomValues.get(t))!==null&&z!==void 0?z:l)!==null&&Q!==void 0?Q:s}function V(A,P){if(P.atomValues.has(t))return q(P.atomValues.get(t));if(P.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const Q=P.nonvalidatedAtoms.get(t),z=n.validator(Q,Le);return l=z instanceof Te?s:Be(z),l}else return s}function y(){l=void 0}function E(A,P,Q){if(P.atomValues.has(t)){const z=q(P.atomValues.get(t));if(z.state==="hasValue"&&Q===z.contents)return new Map}else if(!P.nonvalidatedAtoms.has(t)&&Q instanceof Te)return new Map;return l=void 0,new Map().set(t,Be(Q))}function Y(){return ur(t)!==void 0&&r<=0}const oe=iu({key:t,nodeType:"atom",peek:C,get:V,set:E,init:p,invalidate:y,shouldDeleteConfigOnRelease:Y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return oe}function Tn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return lu(n)?_u({...t,default:n}):vu({...t,default:n})}function _u(e){const t=Tn({...e,default:Le,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Te?o:q(e.persistence_UNSTABLE).validator(o,Le)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=We({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof Te?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return cu(n.key,ur(e.key)),n}Tn.value=e=>new lr(e);var dr=Tn;class pu{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Su={MapCache:pu},Ru=Su.MapCache,mu=Object.freeze({__proto__:null,MapCache:Ru});const{LRUCache:Zn}=ar,{MapCache:yu}=mu,_t={equality:"reference",eviction:"none",maxSize:1/0};function gu({equality:e=_t.equality,eviction:t=_t.eviction,maxSize:n=_t.maxSize}=_t){const o=bu(e);return Tu(t,n,o)}function bu(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw U(`Unrecognized equality policy ${e}`)}function Tu(e,t,n){switch(e){case"keep-all":return new yu({mapKey:n});case"lru":return new Zn({mapKey:n,maxSize:q(t)});case"most-recent":return new Zn({mapKey:n,maxSize:1})}throw U(`Unrecognized eviction policy ${e}`)}var fr=gu;const{setConfigDeletionHandler:Au}=ce;function Eu(e){var t,n;const o=fr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,v="default"in e?e.default:new Promise(()=>{}),p=dr({...f,key:`${e.key}__${(a=Pt(r))!==null&&a!==void 0?a:"void"}`,default:typeof v=="function"?v(r):v,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,p),Au(p.key,()=>{o.delete(r)}),p}}var wu=Eu;const{setConfigDeletionHandler:Nu}=ce;let Lu=0;function Vu(e){var t,n;const o=fr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(C){throw U(`Problem with cache lookup for selector ${e.key}: ${C.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Pt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Lu++}`,u=C=>e.get(r)(C),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let p;if(e.set!=null){const C=e.set;p=We({key:l,get:u,set:(y,E)=>C(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else p=We({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,p),Nu(p.key,()=>{o.delete(r)}),p}}var Ee=Vu;const Cu=Ee({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function $u(e){return Cu(e)}var Mu=$u;const Uu=Ee({key:"__error",get:e=>()=>{throw U(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Iu(e){return Uu(e)}var Du=Iu;function ku(e){return e}var Bu=ku;const{loadableWithError:hr,loadableWithPromise:vr,loadableWithValue:_r}=rt;function Ot(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Pu(e){return e!=null&&!G(e)}function xt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?_r(t[a]):G(r)?vr(r):hr(r));return sn(e,o)}function Ou(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const xu=Ee({key:"__waitForNone",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return Pe(e,o,r)},dangerouslyAllowMutability:!0}),Fu=Ee({key:"__waitForAny",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.some(a=>!G(a))?Pe(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())G(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Pe(e,o,r))}).catch(u=>{r[s]=u,a(Pe(e,o,r))})})},dangerouslyAllowMutability:!0}),zu=Ee({key:"__waitForAll",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);if(r.every(s=>s==null))return sn(e,o);const a=r.find(Pu);if(a!=null)throw a;return Promise.all(r).then(s=>sn(e,Ou(o,s)))},dangerouslyAllowMutability:!0}),Wu=Ee({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.every(a=>!G(a))?Pe(e,o,r):Promise.all(r.map((a,s)=>G(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Pe(e,o,r))},dangerouslyAllowMutability:!0}),Gu=Ee({key:"__noWait",get:e=>({get:t})=>{try{return We.value(_r(t(e)))}catch(n){return We.value(G(n)?vr(n):hr(n))}},dangerouslyAllowMutability:!0});var Ku={waitForNone:xu,waitForAny:Fu,waitForAll:zu,waitForAllSettled:Wu,noWait:Gu};const{RecoilLoadable:Hu}=rt,{DefaultValue:ju}=ce,{RecoilRoot:qu,useRecoilStoreID:Zu}=be,{isRecoilValue:Yu}=xe,{retentionZone:Xu}=Nt,{freshSnapshot:Ju}=Ut,{useRecoilState:Qu,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ed,useRecoilStateLoadable:td,useRecoilValue:nd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:od,useRecoilValueLoadable:rd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ad,useResetRecoilState:sd,useSetRecoilState:id}=Sc,{useGotoRecoilSnapshot:cd,useRecoilSnapshot:ld,useRecoilTransactionObserver:ud}=Jo,{useRecoilCallback:dd}=nr,{noWait:fd,waitForAll:hd,waitForAllSettled:vd,waitForAny:_d,waitForNone:pd}=Ku;var I={DefaultValue:ju,isRecoilValue:Yu,RecoilLoadable:Hu,RecoilEnv:Ge,RecoilRoot:qu,useRecoilStoreID:Zu,useRecoilBridgeAcrossReactRoots_UNSTABLE:Gc,atom:dr,selector:We,atomFamily:wu,selectorFamily:Ee,constSelector:Mu,errorSelector:Du,readOnlySelector:Bu,noWait:fd,waitForNone:pd,waitForAny:_d,waitForAll:hd,waitForAllSettled:vd,useRecoilValue:nd,useRecoilValueLoadable:rd,useRecoilState:Qu,useRecoilStateLoadable:td,useSetRecoilState:id,useResetRecoilState:sd,useGetRecoilValueInfo_UNSTABLE:Pc,useRecoilRefresher_UNSTABLE:ml,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ad,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:od,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:ed,useRecoilCallback:dd,useRecoilTransaction_UNSTABLE:Al,useGotoRecoilSnapshot:cd,useRecoilSnapshot:ld,useRecoilTransactionObserver_UNSTABLE:ud,snapshot_UNSTABLE:Ju,useRetain:Rn,retentionZone:Xu},Sd=I.DefaultValue,Rd=I.isRecoilValue,md=I.RecoilLoadable,yd=I.RecoilEnv,gd=I.RecoilRoot,bd=I.useRecoilStoreID,Td=I.useRecoilBridgeAcrossReactRoots_UNSTABLE,Ad=I.atom,Ed=I.selector,wd=I.atomFamily,Nd=I.selectorFamily,Ld=I.constSelector,Vd=I.errorSelector,Cd=I.readOnlySelector,$d=I.noWait,Md=I.waitForNone,Ud=I.waitForAny,Id=I.waitForAll,Dd=I.waitForAllSettled,kd=I.useRecoilValue,Bd=I.useRecoilValueLoadable,Pd=I.useRecoilState,Od=I.useRecoilStateLoadable,xd=I.useSetRecoilState,Fd=I.useResetRecoilState,zd=I.useGetRecoilValueInfo_UNSTABLE,Wd=I.useRecoilRefresher_UNSTABLE,Gd=I.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,Kd=I.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,Hd=I.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,jd=I.useRecoilCallback,qd=I.useRecoilTransaction_UNSTABLE,Zd=I.useGotoRecoilSnapshot,Yd=I.useRecoilSnapshot,Xd=I.useRecoilTransactionObserver_UNSTABLE,Jd=I.snapshot_UNSTABLE,Qd=I.useRetain,ef=I.retentionZone;const of=Object.freeze(Object.defineProperty({__proto__:null,DefaultValue:Sd,RecoilEnv:yd,RecoilLoadable:md,RecoilRoot:gd,atom:Ad,atomFamily:wd,constSelector:Ld,default:I,errorSelector:Vd,isRecoilValue:Rd,noWait:$d,readOnlySelector:Cd,retentionZone:ef,selector:Ed,selectorFamily:Nd,snapshot_UNSTABLE:Jd,useGetRecoilValueInfo_UNSTABLE:zd,useGotoRecoilSnapshot:Zd,useRecoilBridgeAcrossReactRoots_UNSTABLE:Td,useRecoilCallback:jd,useRecoilRefresher_UNSTABLE:Wd,useRecoilSnapshot:Yd,useRecoilState:Pd,useRecoilStateLoadable:Od,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Hd,useRecoilStoreID:bd,useRecoilTransactionObserver_UNSTABLE:Xd,useRecoilTransaction_UNSTABLE:qd,useRecoilValue:kd,useRecoilValueLoadable:Bd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Gd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Kd,useResetRecoilState:Fd,useRetain:Qd,useSetRecoilState:xd,waitForAll:Id,waitForAllSettled:Dd,waitForAny:Ud,waitForNone:Md},Symbol.toStringTag,{value:"Module"}));export{gd as R,yd as a,wd as b,Ad as c,Ed as d,of as e,jd as f,Pd as g,Od as h,Bd as i,kd as j};
